/*
 * FFTDisplayPanel.java
 *
 * Created on August 2, 2004, 5:01 PM
 */

package musicretrievaldemo.fft;

import java.awt.*;

/**
 *
 * @author  dwhoiem Derek Hoiem
 */
public class FFTDisplayPanel extends javax.swing.JPanel {
     private int calculating = 0;
     private int minFreq = 300;
     private int maxFreq = 2000;
     private int numBands = 33;
     private int windowSize = 1024;
     private int windowStep = 128;
    
     private Image originalFFTImage = null;
     private Image recordedFFTImage = null;     
     
    /** Creates new form FFTDisplayPanel */
    public FFTDisplayPanel() {        
        initComponents();               
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        
        setLayout(new BorderLayout());
        
    }//GEN-END:initComponents
    
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);        

        //this.setBackground(new Color(50, 50, 50));
        if (recordedFFTImage != null) {

            g.drawImage(recordedFFTImage,0, 0, this);
                   // this.getWidth()/2, this.getHeight(), this);            
        }
        
        if (originalFFTImage != null) {
            g.drawImage(originalFFTImage,this.getWidth()/2+10, 0, this);            
        }        
        
        if (calculating != 0) {
            int x = calculating == 1 ? getWidth() / 5 : 3 * getWidth() / 5;
            g.drawString("Calculating....", x, getHeight() / 2);
            //System.out.println("Calculating " + calculating);
        }
            
        
    }
    
    // x^numBands*min = max --> x = exp(log(max/min)/numBands)
    private double[] getFreqBoundaries(int min, int max, int numBands) {
        double logRatio = Math.log((double)(max)/(double)(min));
        double x = Math.exp(logRatio / numBands);
        double[] freqs = new double[numBands+1];
        freqs[0] = min;
        for (int i=1; i<=numBands; i++) {
            freqs[i] = freqs[i-1]*x;
        }
        return freqs;        
    }
    /*
    private double[][] normalize(double[][] matrix) {                
        double max = Math.log(matrix[0][0]+1E-10);
        double min = Math.log(matrix[0][0]+1E-10);
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = Math.log(matrix[i][j]+1E-10);
                if (matrix[i][j] > max)
                    max = matrix[i][j];
                else if (matrix[i][j] < min)
                    min = matrix[i][j];                                    
            }
        }
        
        System.out.println("min-max" + min + " " + max);
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                
                matrix[i][j] = (matrix[i][j]-min)/(max-min);                                
            }
        }
        return matrix;
    }*/
    
    private double[][] normalize(double[][] matrix) {                
        double max = Math.sqrt(matrix[0][0]);
        double min = Math.sqrt(matrix[0][0]);
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = Math.sqrt(matrix[i][j]);
                if (matrix[i][j] > max)
                    max = matrix[i][j];
                else if (matrix[i][j] < min)
                    min = matrix[i][j];                                    
            }
        }
        
        //System.out.println("min-max  " + min + " " + max);
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                
                matrix[i][j] = (matrix[i][j]-min)/(max-min);                                
            }
        }
        return matrix;
    }
    
    
    // mag ranges from 0.0 to 1.0
    private Color getMagnitudeColor(double mag) {
        Color[] colors = new Color[]{
                new Color(0, 0, 0), new Color(0, 0, 255), new Color(0, 255, 255),
                new Color(0, 255, 0), new Color(255, 255, 0), new Color(255, 0, 0), 
                new Color(255, 128, 128), new Color(255, 255, 255)};
        /*Color[] colors = new Color[]{
                new Color(0, 0, 0), new Color(0, 0, 255), new Color(0, 255, 255),
                new Color(255, 255, 0), new Color(255, 0, 0), 
                new Color(255, 128, 128), new Color(255, 255, 255)};*/
                
        int numColors = colors.length;
        
        double colorLoc = Math.min(mag*numColors, numColors-1);
        
        int lowCol = (int)(Math.floor(colorLoc));
        int highCol = (int)(Math.ceil(colorLoc));
        double lowStrength = (double)(highCol - colorLoc);
        double highStrength = 1.0 - lowStrength;
        
        int r = (int)(colors[lowCol].getRed()*lowStrength + 
                      colors[highCol].getRed()*highStrength);
        int g = (int)(colors[lowCol].getGreen()*lowStrength + 
                      colors[highCol].getGreen()*highStrength);
        int b = (int)(colors[lowCol].getBlue()*lowStrength + 
                      colors[highCol].getBlue()*highStrength);
        Color magColor = new Color(r, g, b);
        
        return magColor;
    }
    
    /**
     * data[height][width]
     * The number of elements in xvals and yvals is always one above width 
     * and height, respectively.  xvals and yvals may be null.
     */ 
    private Image matrixToImage(double[][] data, double[] xvals, double[] yvals, 
                                int imageWidth, int imageHeight) {                
        Image image = this.createImage(imageWidth, imageHeight);
        Graphics g = image.getGraphics();
        
        int x, nextx, y, nexty, width, height;
        for (int j = 0; j < data.length-1; j++) {
            for (int i = 0; i < data[j].length-1; i++) {
                double mag = data[j][i];
                Color magColor = getMagnitudeColor(mag);
                g.setColor(magColor);
                if (xvals == null) {
                    x = (int)((double)imageWidth/(double)(data[j].length+1) * (double)i);
                    nextx = (int)((double)imageWidth/(double)(data[j].length+1) * (double)(i+1));
                    width = nextx-x+1;
                }
                else {
                    x = (int)(xvals[i]*imageWidth/xvals[xvals.length-1]);
                    width = Math.max((int)(imageWidth/xvals[xvals.length-1]*xvals[i+1]-x),1);
                    
                }
                 if (yvals == null) {
                    y = (int)(imageHeight/(double)(data.length+1) * j);
                    nexty = (int)(imageHeight/(double)(data.length+1) * (j+1));                    
                 }
                else {
                    y = (int)((yvals[j]-yvals[0])/(yvals[yvals.length-1]-yvals[0])*imageHeight);
                    nexty = (int)((yvals[j+1]-yvals[0])/(yvals[yvals.length-1]-yvals[0])*imageHeight);                   
                }
                height = nexty-y+1;
                g.setColor(magColor);
                g.fillRect(x, imageHeight-(y+1), width, height);
            }
        }
           
        return image;
        
    }
    
   
    public void displayFFT(double[] data, int fs, boolean isRecorded) {
        
        //FFTThread fftThread = new FFTThread(this, isRecorded);
        if (isRecorded) {
            calculating = 1;
            recordedFFTImage = null;
        } else {
            calculating = 2;
            originalFFTImage = null;
        }
        
        //System.out.println(" displayffT(): calculating " + calculating);
        
        repaint();
        //try { Thread.sleep(100); } catch (Exception e) {}
        
        double[] freqs = getFreqBoundaries(minFreq, maxFreq, numBands);
                
        windowSize = (int)Math.pow(2, (int)(Math.log(data.length / 200+1)/Math.log(2)));
        windowSize = Math.max(windowSize, 1024);
        windowStep = windowSize / 8;

        double[][] windowedFFTMatrix = 
                SignalManipulation.performWindowedFFT(data, fs, freqs, windowSize, windowStep);
                                
        // matrix is in form matrix[bands][time]
        windowedFFTMatrix = normalize(windowedFFTMatrix);

        if (isRecorded) {
            recordedFFTImage = matrixToImage(windowedFFTMatrix, null, null, 
                                             this.getWidth()/2-10, this.getHeight());            
        }
        else {
            originalFFTImage = matrixToImage(windowedFFTMatrix, null, null,
                                             this.getWidth()/2-10, this.getHeight());
        }
        
        calculating = 0;
        
        this.repaint();

        

        
    }
    
    public void clearDisplay() {
        //System.out.println("clearing display");
        recordedFFTImage = null;
        originalFFTImage = null;
        repaint();
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
       
    
}

/*
public class FFTThread extends Thread {
    
    FFTDisplayPanel display;
    boolean isRecorded;
    
    private int minFreq = 300;
    private int maxFreq = 2000;
    private int numBands = 33;
    private int windowSize = 1024;
    private int windowStep = 128;
    
    public FFTThread(FFTDisplayPanel display, boolean isRecorded) {
        this.display = display;
        this.isRecorded = isRecorded;        
    }
    
    public void run() {
        double[] freqs = display.getFreqBoundaries(minFreq, maxFreq, numBands);
                
        int windowSize = (int)Math.pow(2, (int)(Math.log(data.length / 200+1)/Math.log(2)));
        windowSize = Math.max(windowSize, 1024);
        int windowStep = windowSize / 8;

        double[][] windowedFFTMatrix = 
                SignalManipulation.performWindowedFFT(data, fs, freqs, windowSize, windowStep);
                                
        // matrix is in form matrix[bands][time]
        windowedFFTMatrix = display.normalize(windowedFFTMatrix);

        if (isRecorded) {
            recordedFFTImage = display.matrixToImage(windowedFFTMatrix, null, null, 
                                             display.getWidth()/2-10, display.getHeight());            
        }
        else {
            originalFFTImage = display.matrixToImage(windowedFFTMatrix, null, null,
                                             display.getWidth()/2-10, display.getHeight());
        }
        
        display.repaint();
    }
}*/
